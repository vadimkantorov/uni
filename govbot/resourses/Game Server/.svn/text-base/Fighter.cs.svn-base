using System;
using System.Collections.Generic;
using System.Drawing;
using DCIMAP.GANS.SwarmIntellect;

namespace GAME
{
    public enum FighterType
    {
        Pistol,
        Minigun,
        Sniper,
        Rocket,
        Fatman
    }

    public class Fighter: AbstractObject<Coordinate2D, Metric2D, int>
    {

        public Fighter(Map<Coordinate2D, Metric2D, int> map):base(map)
        {
            back = (GameBackground) background;
        }

        #region Generated by Thornado

        ///<summary>
        ///Текущее положение башки
        ///</summary>
        private double _angle;

        ///<summary>
        ///Место возрождения
        ///</summary>
        private Point _birthlocation;

        ///<summary>
        ///Повреждение
        ///</summary>
        private int _damage;

        ///<summary>
        ///Мертв ли этот юнит
        ///</summary>
        private bool _dead;

        ///<summary>
        ///Отчет до возрождения
        ///</summary>
        private int _deadcountdown;

        ///<summary>
        ///Хитпоинты
        ///</summary>
        private int _hp;

        ///<summary>
        ///Последнее сообщение в эфир
        ///</summary>
        private string _lasteth;

        ///<summary>
        ///Буква, которая зависит от типа, которая отображается в просмотре
        ///</summary>
        private string _letter;

        ///<summary>
        ///Положение юнита
        ///</summary>
        private Point _location;

        ///<summary>
        ///Количество маны
        ///</summary>
        private int _mana;

        ///<summary>
        ///Номер в команде
        ///</summary>
        private int _number;

        ///<summary>
        ///Шанс на попадание, в процентах (100 - всегда попадает, 0 - никогда)
        ///</summary>
        private int _precision;

        ///<summary>
        ///Радиус поражения
        ///</summary>
        private int _radius;

        ///<summary>
        ///Стоимость выстрела
        ///</summary>
        private int _shotcost;

        ///<summary>
        ///Угол обзора
        ///</summary>
        private double _sightangle;

        ///<summary>
        ///Дальность обзора
        ///</summary>
        private double _sightlength;

        ///<summary>
        ///Возможная дальность
        ///</summary>
        private int _speed;

        ///<summary>
        ///Номер команды
        ///</summary>
        private int _team;

        ///<summary>
        ///Положение юнита
        ///</summary>
        public Point Location
        {
            get { return _location; }
            set { _location = value; }
        }

        ///<summary>
        ///Мертв ли этот юнит
        ///</summary>
        public bool Dead
        {
            get { return _dead; }
            set { _dead = value; }
        }

        ///<summary>
        ///Отчет до возрождения
        ///</summary>
        public int DeadCountDown
        {
            get { return _deadcountdown; }
            set { _deadcountdown = value; }
        }

        ///<summary>
        ///Место возрождения
        ///</summary>
        public Point BirthLocation
        {
            get { return _birthlocation; }
            set { _birthlocation = value; }
        }

        ///<summary>
        ///Хитпоинты
        ///</summary>
        public int HP
        {
            get { return _hp; }
            set { _hp = value; }
        }

        ///<summary>
        ///Буква, которая зависит от типа, которая отображается в просмотре
        ///</summary>
        public string Letter
        {
            get { return _letter; }
            set { _letter = value; }
        }

        ///<summary>
        ///Номер команды
        ///</summary>
        public int Team
        {
            get { return _team; }
            set { _team = value; }
        }

        ///<summary>
        ///Номер в команде
        ///</summary>
        public int Number
        {
            get { return _number; }
            set { _number = value; }
        }

        ///<summary>
        ///Текущее положение башки
        ///</summary>
        public double Angle
        {
            get { return _angle; }
            set { _angle = value; }
        }

        ///<summary>
        ///Угол обзора
        ///</summary>
        public double SightAngle
        {
            get { return _sightangle; }
            set { _sightangle = value; }
        }

        ///<summary>
        ///Дальность обзора
        ///</summary>
        public double SightLength
        {
            get { return _sightlength; }
            set { _sightlength = value; }
        }

        ///<summary>
        ///Количество маны
        ///</summary>
        public int Mana
        {
            get { return _mana; }
            set { _mana = value; }
        }

        ///<summary>
        ///Стоимость выстрела
        ///</summary>
        public int ShotCost
        {
            get { return _shotcost; }
            set { _shotcost = value; }
        }

        ///<summary>
        ///Возможная дальность
        ///</summary>
        public int Speed
        {
            get { return _speed; }
            set { _speed = value; }
        }

        ///<summary>
        ///Радиус поражения
        ///</summary>
        public int Radius
        {
            get { return _radius; }
            set { _radius = value; }
        }

        ///<summary>
        ///Повреждение
        ///</summary>
        public int Damage
        {
            get { return _damage; }
            set { _damage = value; }
        }

        ///<summary>
        ///Шанс на попадание, в процентах (100 - всегда попадает, 0 - никогда)
        ///</summary>
        public int Precision
        {
            get { return _precision; }
            set { _precision = value; }
        }

        ///<summary>
        ///Последнее сообщение в эфир
        ///</summary>
        public string LastEth
        {
            get { return _lasteth; }
            set { _lasteth = value; }
        }

        #endregion

        #region Control 

        private const int maxHP = 100;
        private const int maxMana = 20;

        private GameBackground back;
        private FighterController controller;


        

        protected override TurnActionInfo<Coordinate2D, Metric2D, int> OnTurn(SubMap<Coordinate2D, Metric2D, int> submap)
        {
            List<Fighter> lst = new List<Fighter>();
            //foreach(Cell<Coordinate2D, Metric2D, int> c in submap.Cells)
                foreach(Fighter f in submap.Objects)
                {
                    if(f == this)
                        continue;
                    if(back.CanSee(Location.X, Location.Y, f.Location.X, f.Location.Y, SightLength, Angle, SightAngle))
                        lst.Add(f);
                }
            //FighterControllerData move = controller.MakeTurn(this, lst, back.Eth[Team]);
            FighterControllerData move = controller.MakeTurn(this, lst, ether.Get<string[]>(Team.ToString()));

            TurnActionInfo<Coordinate2D, Metric2D, int> inf = new TurnActionInfo<Coordinate2D, Metric2D, int>();

            if(Dead)
            {
                DeadCountDown--;
                if(DeadCountDown == 0)
                {
                    Dead = false;
                    inf.hasMoved = true;
                    inf.moveTo = submap.ToLocal(new Coordinate2D(BirthLocation.X, BirthLocation.Y));
                }
            }
            else
            {
                if(move.shot)
                    if(Mana >= ShotCost)
                    {
                        Mana -= ShotCost;
                        for(int dx = -Radius; dx <= Radius; dx++)
                            for(int dy = -Radius; dy <= Radius; dy++)
                                if(back.Inside(move.shotPoint.X + dx, move.shotPoint.Y + dy))
                                {
                                    Cell<Coordinate2D, Metric2D, int> cl =
                                        submap.GetCell(
                                            submap.ToLocal(new Coordinate2D(move.shotPoint.X + dx, move.shotPoint.Y + dy)));
                                    foreach(Fighter f in cl)
                                        f.HP -= move.damage;
                                }
                    }

                if(back.CanGo(Location.X, Location.Y, move.newLocation.X, move.newLocation.Y, Speed))
                {
                    inf.hasMoved = true;
                    inf.moveTo = submap.ToLocal(new Coordinate2D(move.newLocation.X, move.newLocation.Y));
                }
                else
                    inf.hasMoved = false;
                Angle = move.newAngle;
                LastEth = move.msg;
            }

            return inf;
        }

        protected override StateChangeInfo OnAfterTurn(Cell<Coordinate2D, Metric2D, int> cell)
        {
            if(HP <= 0)
            {
                Dead = true;
                DeadCountDown = 5;
                HP = maxHP;
                Mana = maxMana;
                back.deadCount[Team]++;
            }
            Mana = Math.Min(maxMana, Mana + 1);
            Location = new Point(cell.Coordinate.X, cell.Coordinate.Y);
            //back.Eth[Team][Number] = LastEth;
            ether.Get<string[]>(Team.ToString())[Number] = LastEth;
            return StateChangeInfo.None;
        }

        #endregion

        #region Generation of fighters

        public static string GoodLetters
        {
            get { return "PMSRF"; }
        }

        public static Fighter CreateFighter(Map<Coordinate2D,Metric2D,int> map, int team, int number, char type,
                                            FighterController control)
        {
            Fighter f = new Fighter(map);
            //common properties
            f._hp = maxHP;
            f._letter = type.ToString()[0].ToString();
            f._team = team;
            f._number = number;
            f._mana = maxMana;
            f.controller = control;
            f.SightLength = 50;
            f.SightAngle = Math.PI / 4;
            Point p = new Point(team == 0 ? 0 : ((GameBackground)map.Background).Width - 1, 10 * number);
            f.Location = p;
            f.BirthLocation = p;
            f.Angle = team == 0 ? 0 : Math.PI;
            f.eyeshot = new Metric2D(10000, 10000);

            switch (type)
            {
                case 'P':
                    f.Damage = 70;
                    f.Precision = 50;
                    f.Speed = 15;
                    f.ShotCost = 3;
                    break;
                case 'M':
                    f.Damage = 40;
                    f.Precision = 100;
                    f.Speed = 12;
                    f.ShotCost = 2; 
                    break;
                case 'S':
                    f.Damage = 100;
                    f.Precision = 90;
                    f.Speed = 10;
                    f.ShotCost = 5;
                    f.SightAngle /= 3;
                    f.SightLength *= 2;
                    break;
                case 'R':
                    f.Damage = 100;
                    f.Precision = 90;
                    f.Speed = 10;
                    f.ShotCost = 10;
                    f.Radius = 5;
                    break;
                case 'F':
                    f.Damage = 100;
                    f.Precision = 100;
                    f.Speed = 10;
                    f.ShotCost = 20;
                    f.Radius = 10;
                    break;
            }
            return f;
        }

        #endregion
    }
}